type UserProxy @entity {
  id: ID!
  proxyAddress: Bytes!
  owner: Bytes!
}

interface PositionTransactionAction {
  id: ID!
  collateral: BigInt!
  deltaCollateral: BigInt!
  normalDebt: BigInt!
  timestamp: BigInt!
  deltaNormalDebt: BigInt!
  transactionHash: Bytes!
  position: Position!
  vault: Vault
  vaultName: String
  tokenId: BigInt!
  user: Bytes!
}

type ModifyCollateralAndDebtAction implements PositionTransactionAction @entity {
  id: ID!
  collateral: BigInt!
  normalDebt: BigInt!
  transactionHash: Bytes!
  timestamp: BigInt!
  position: Position!
  # Event Properties
  vault: Vault
  vaultName: String
  tokenId: BigInt!
  user: Bytes!
  collateralizer: Bytes!
  creditor: Bytes!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
}

type TransferCollateralAndDebtAction implements PositionTransactionAction @entity {
  id: ID!
  collateral: BigInt!
  normalDebt: BigInt!
  transactionHash: Bytes!
  timestamp: BigInt!
  position: Position!
  user: Bytes!
  # Event Properties
  vault: Vault
  vaultName: String
  tokenId: BigInt!
  userSrc: Bytes!
  userDst: Bytes!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
}

type ConfiscateCollateralAndDebtAction implements PositionTransactionAction @entity {
  id: ID!
  collateral: BigInt!
  normalDebt: BigInt!
  transactionHash: Bytes!
  timestamp: BigInt!
  position: Position!
  # Event Properties
  vault: Vault
  vaultName: String
  tokenId: BigInt!
  user: Bytes!
  collateralizer: Bytes!
  debtor: Bytes!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
}

type Position @entity {
  id: ID!
  vault: Vault
  vaultName: String
  collateralType: CollateralType
  users: User!
  owner: Bytes!
  collateral: BigInt!
  normalDebt: BigInt!
  maturity: BigInt
  positionTransactions: [PositionTransactionAction!] @derivedFrom(field: "position")
}

type Codex @entity {
  id: ID!
  delegates: Delegate
  vault: Vault
  globalDebtCeiling: BigInt!
  isAlive: BigInt
}

type Balance @entity {
  id: ID!
  balance: BigInt
  vault: Bytes
  tokenId: BigInt
  owner: Bytes
}

type Delegate @entity {
  id: ID!
  delegator: Bytes!
  delegatee: Bytes!
  hasDelegate: BigInt
  # Reverse look-up from this entity to the Codex entity
  codex: [Codex!] @derivedFrom(field: "delegates")
}

enum VaultType {
  ELEMENT,
  BARNBRIDGE,
  NOTIONAL
}

type Vault @entity {
  id: ID!
  address: Bytes
  name: String
  type: VaultType
  collateralizationRatio: BigInt
  interestPerSecond: BigInt
  debtFloor: BigInt
  debtCeiling: BigInt

  # Auction related data
  # Multiplicative factor to increase start price [wad]
  multiplier: BigInt
  # Time elapsed before auction reset [seconds]
  maxAuctionDuration: BigInt
  # Percentage drop before auction reset [percentage in wad]
  maxDiscount: BigInt
  # Cache (v.debtFloor * v.liquidationPenalty) to prevent excessive SLOADs [wad]
  auctionDebtFloor: BigInt

  # One-to-many relation with Collybus
  collybus: Collybus

  positions: [Position!] @derivedFrom(field: "vault")
  collateralTypes: [CollateralType!] @derivedFrom(field: "vault")
  codex: [Codex!] @derivedFrom(field: "vault")
}

type CollateralType @entity {
  id: ID!
  tokenId: BigInt
  address: Bytes
  symbol: String
  maturity: BigInt
  underlierSymbol: String
  underlierAddress: Bytes
  underlierScale: BigInt
  vault: Vault
  vaultName: String
  faceValue: BigInt
  depositedCollateral: BigInt

  # Only valid when collateral is a Element pToken
  eptData: EPTData
}

# Element pToken ConvergentPool data
type EPTData @entity {
  # pToken address
  id: ID!

  balancerVault: Bytes

  # Element pToken ConvergentCurvePool address
  convergentCurvePool: Bytes
  # Element pToken ConvergentCurvePool id
  poolId: Bytes

  vault: [CollateralType!] @derivedFrom(field: "eptData")
}

type User @entity {
  id: ID!
  owner: Bytes
  totalCollateral: BigInt
  totalCredit: BigInt
  totalNormalDebt: BigInt
  positions: [Position!] @derivedFrom(field: "users")
}

type FIAT @entity {
  id: ID!
  address: Bytes
  minted: BigInt
  burned: BigInt
  totalSupply: BigInt
}

type FIATTokenAllowance @entity {
  id: ID!
  owner: Bytes
  spender: Bytes
  amount: BigInt
}

type FIATTokenBalance @entity {
  id: ID!
  address: Bytes
  balance: BigInt
}

type CollateralAuction @entity {
  id: ID!
  # Contract Generated Id
  auctionId: BigInt
  # Debt to sell == Credit to raise [wad]
  debt: BigInt
  # collateral to sell [wad]
  collateralToSell: BigInt
  # Vault of the liquidated Positions collateral
  vault: Vault
  vaultName: String
  # TokenId of the liquidated Positions collateral
  tokenId: BigInt
  collateralType: CollateralType
  # Owner of the liquidated Position
  user: Bytes
  # Auction start time
  startsAt: BigInt
  # Starting price [wad]
  startPrice: BigInt
  # Keeper
  keeper: Bytes
  # Tip
  tip: BigInt
  isActive: Boolean
}

type Collybus @entity {
 id: ID!
 # One-to-many reverse lookup with CollybusSpot's `collybus` field
 spots: [CollybusSpot!] @derivedFrom(field: "collybus")

 # One-to-many reverse lookup with CollybusDiscountRate's `collybus` field
 rates: [CollybusDiscountRate!] @derivedFrom(field: "collybus")

 # One-to-many reverse lookup with Vault's `collybus` field
 vaults: [Vault!] @derivedFrom(field: "collybus")
}

type CollybusSpot @entity {
  id: ID!
  token: Bytes
  spot: BigInt

  # One-to-many relation with Collybus
  collybus: Collybus
}

type CollybusDiscountRate @entity {
  id: ID!
  rateId: BigInt
  discountRate: BigInt

  # One-to-many relation with Collybus
  collybus: Collybus
}