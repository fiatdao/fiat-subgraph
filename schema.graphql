type UserProxy @entity {
  id: ID!
  proxyAddress: Bytes!
  owner: Bytes!
}

interface PositionTransactionAction {
  id: ID!
  transactionHash: Bytes!
  vault: Vault
  vaultName: String # same as vault.name (workaround)
  tokenId: BigInt!
  position: Position!
  user: Bytes!
  collateral: BigInt!
  normalDebt: BigInt!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
  timestamp: BigInt!
}

type ModifyCollateralAndDebtAction implements PositionTransactionAction @entity {
  id: ID!
  transactionHash: Bytes!
  vault: Vault
  vaultName: String # same as vault.name (workaround)
  tokenId: BigInt!
  position: Position!
  user: Bytes!
  collateral: BigInt!
  normalDebt: BigInt!
  collateralizer: Bytes!
  creditor: Bytes!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
  timestamp: BigInt!
}

type TransferCollateralAndDebtAction implements PositionTransactionAction @entity {
  id: ID!
  transactionHash: Bytes!
  vault: Vault
  vaultName: String # same as vault.name (workaround)
  tokenId: BigInt!
  position: Position!
  user: Bytes!
  userSrc: Bytes!
  userDst: Bytes!
  collateral: BigInt!
  normalDebt: BigInt!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
  timestamp: BigInt!
}

type ConfiscateCollateralAndDebtAction implements PositionTransactionAction @entity {
  id: ID!
  transactionHash: Bytes!
  vault: Vault
  vaultName: String # same as vault.name (workaround)
  tokenId: BigInt!
  position: Position!
  user: Bytes!
  collateralizer: Bytes!
  debtor: Bytes!
  collateral: BigInt!
  normalDebt: BigInt!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
  timestamp: BigInt!
}

type Position @entity {
  id: ID!
  vault: Vault
  vaultName: String # same as vault.name (workaround)
  collateralType: CollateralType
  owner: Bytes!
  users: User!
  collateral: BigInt!
  normalDebt: BigInt!
  maturity: BigInt
  positionTransactions: [PositionTransactionAction!] @derivedFrom(field: "position")
}

type Codex @entity {
  id: ID!
  delegates: Delegate
  globalDebtCeiling: BigInt!
}

type Balance @entity {
  id: ID!
  vault: Bytes
  tokenId: BigInt
  owner: User
  balance: BigInt
}

type Delegate @entity {
  id: ID!
  delegator: Bytes!
  delegatee: Bytes!
  hasDelegate: BigInt
  codex: [Codex!] @derivedFrom(field: "delegates")
}

enum VaultType {
  ELEMENT,
  NOTIONAL,
  Yield,
  BARNBRIDGE,
}

type Vault @entity {
  id: ID!
  address: Bytes
  name: String
  type: VaultType
  vaultType: Bytes
  collateralizationRatio: BigInt
  interestPerSecond: BigInt
  defaultRateId: BigInt
  debtFloor: BigInt
  debtCeiling: BigInt

  # Auction related data
  multiplier: BigInt
  maxAuctionDuration: BigInt
  maxDiscount: BigInt
  auctionDebtFloor: BigInt

  positions: [Position!] @derivedFrom(field: "vault")
  collateralTypes: [CollateralType!] @derivedFrom(field: "vault")
}

type CollateralType @entity {
  id: ID!
  tokenId: BigInt
  address: Bytes # rename to tokenAddress
  symbol: String # rename to tokenSymbol
  scale: BigInt # rename to tokenScale
  underlierSymbol: String
  underlierAddress: Bytes
  underlierScale: BigInt
  vault: Vault
  vaultName: String # same as vault.name (workaround)
  faceValue: BigInt
  depositedCollateral: BigInt
  maturity: BigInt

  # Only set for Element Finance pTokens
  eptData: EPTData
}

type EPTData @entity {
  id: ID!
  balancerVault: Bytes
  convergentCurvePool: Bytes
  poolId: Bytes
  vault: [CollateralType!] @derivedFrom(field: "eptData")
}

type User @entity {
  id: ID!
  address: Bytes
  credit: BigInt
  balances: [Balance!] @derivedFrom(field: "owner")
  positions: [Position!] @derivedFrom(field: "users")
}

type FIAT @entity {
  id: ID!
  address: Bytes
  minted: BigInt
  burned: BigInt
  totalSupply: BigInt
}

type FIATTokenAllowance @entity {
  id: ID!
  owner: Bytes
  spender: Bytes
  amount: BigInt
}

type FIATTokenBalance @entity {
  id: ID!
  address: Bytes
  balance: BigInt
}

type CollateralAuction @entity {
  id: ID!
  auctionId: BigInt
  debt: BigInt
  collateralToSell: BigInt
  vault: Vault
  vaultName: String # same as vault.name (workaround)
  tokenId: BigInt
  collateralType: CollateralType
  user: Bytes
  startsAt: BigInt
  startPrice: BigInt
  keeper: Bytes
  tip: BigInt
  isActive: Boolean
}

type Collybus @entity {
 id: ID!
 spots: [CollybusSpot!] @derivedFrom(field: "collybus")
 rates: [CollybusDiscountRate!] @derivedFrom(field: "collybus")
}

type CollybusSpot @entity {
  id: ID!
  token: Bytes
  spot: BigInt
  collybus: Collybus
}

type CollybusDiscountRate @entity {
  id: ID!
  rateId: BigInt
  discountRate: BigInt
  collybus: Collybus
}