type UserProxy @entity {
  id: ID!
  proxyAddress: Bytes!
  userAddress: Bytes!
}

interface PositionTransactionAction {
  id: ID!
  collateral: BigInt!
  deltaCollateral: BigInt!
  normalDebt: BigInt!
  deltaNormalDebt: BigInt!
  transactionHash: Bytes!
  position: Position!
  vault: Bytes!
  tokenId: BigInt!
  user: Bytes!
}

type ModifyCollateralAndDebtAction implements PositionTransactionAction @entity {
  id: ID!
  collateral: BigInt!
  normalDebt: BigInt!
  transactionHash: Bytes!
  position: Position!
  # Event Properties
  vault: Bytes!
  tokenId: BigInt!
  user: Bytes!
  collateralizer: Bytes!
  creditor: Bytes!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
}

type TransferCollateralAndDebtAction implements PositionTransactionAction @entity {
  id: ID!
  collateral: BigInt!
  normalDebt: BigInt!
  transactionHash: Bytes!
  position: Position!
  user: Bytes!
  # Event Properties
  vault: Bytes!
  tokenId: BigInt!
  userSrc: Bytes!
  userDst: Bytes!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
}

type ConfiscateCollateralAndDebtAction implements PositionTransactionAction @entity {
  id: ID!
  collateral: BigInt!
  normalDebt: BigInt!
  transactionHash: Bytes!
  position: Position!
  # Event Properties
  vault: Bytes!
  tokenId: BigInt!
  user: Bytes!
  collateralizer: Bytes!
  debtor: Bytes!
  deltaCollateral: BigInt!
  deltaNormalDebt: BigInt!
}

type Position @entity {
  id: ID!
  vault: Vault
  collateral: Collateral
  userPosition: UserPosition!
  totalCollateral: BigInt!
  totalNormalDebt: BigInt!
  maturity: BigInt
  positionTransactions: [PositionTransactionAction!] @derivedFrom(field: "position")
}

enum VaultType {
  ELEMENT,
  BARNBRIDGE,
  NOTIONAL
}

type Vault @entity {
  id: ID!
  address: Bytes
  name: String
  type: VaultType
  collaterizationRatio: BigInt
  positions: [Position!] @derivedFrom(field: "vault")
  collaterals: [Collateral!] @derivedFrom(field: "vault")
}

type Collateral @entity {
  id: ID!
  tokenId: BigInt
  address: Bytes
  symbol: String
  maturity: BigInt
  underlierSymbol: String
  underlierAddress: Bytes
  vault: Vault
  faceValue: BigInt
  depositedCollateral: BigInt
}

type UserPosition @entity {
  id: ID!
  userAddress: Bytes
  totalCollateral: BigInt
  totalFIAT: BigInt
  positions: [Position!] @derivedFrom(field: "userPosition")
}

type FiatData @entity {
  id: ID!
  address: Bytes
  minted: BigInt
  burned: BigInt
  totalSupply: BigInt
}
